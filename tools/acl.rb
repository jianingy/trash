#!/usr/bin/ruby -wKU

require 'yaml'
require 'pp'

$options = { :conf_root => '/etc/firewall' }

def warn(reason)
  puts "WARN: #{reason}"
end

def effective?(s)
  !s.nil? and s.length > 0 and !/\bany\b/i.match(s)
end

def make_host_rule(opt)
  rule = ""

# interface
  rule << "-i #{opt[:inface]} " \
    if opt.include?(:inface) and effective? opt[:inface]
  rule << "-o #{opt[:outface]} " \
    if opt.include?(:outface) and effective? opt[:outface]

# protocol
  rule << "-p #{opt[:proto]} " \
    if opt.include?(:proto) and effective? opt[:proto]

# address
  rule << "-s #{opt[:srchost]} " \
    if opt.include?(:srchost) and effective? opt[:srchost]
  rule << "-d #{opt[:dsthost]} " \
    if opt.include?(:dsthost) and effective? opt[:dsthost]

# port
  rule << "--sport #{opt[:srcport].gsub(/-/, ':')} " \
    if opt.include?(:srcport) and effective? opt[:srcport]
  rule << "--dport #{opt[:dstport].gsub(/-/, ':')} " \
    if opt.include?(:dstport) and effective? opt[:dstport]

  return rule.strip
end

def make_acl_input
  ipt_rules = []
  acl_file = File.join($options[:conf_root], 'input')
  begin
    File.readlines(acl_file).each_with_index do |rule, no|
      case rule
        when %r{^(allow|deny)
                \s+([0-9:,-]+)(?:/(tcp|udp|any))?
                \s+from\s+([0-9./]+|any)}x
        next_chain = $1
        rule = make_host_rule(:dstport => $2, :proto => $3, :srchost => $4)
        if rule.length == 0
          warn "#{acl_file}: line #{no}: insufficent parameter"
          next
        end
        next_chain = case next_chain
                     when /allow/i
                       "ACCEPT"
                     when /deny/i
                       "DENY"
                     end
        ipt_rules << "-A acl-input -m multiport #{rule} -j #{next_chain}"
      end
    end
  rescue Exception => e
      warn "failed on processing #{acl_file}: #{e}"
  ensure
    input_rule = ipt_rules.join("\n")
    return input_rule
  end
end

def make_acl_nat
  ipt_nat_rules = []
  ipt_input_rules = []
  acl_file = File.join($options[:conf_root], 'nat')
  begin
    File.readlines(acl_file).each_with_index do |rule, no|

      case rule
      when %r{^dnat
              (?:\s+in-interface\s+(\w+))?
              (?:\s+dst-address\s+([0-9./]+))?
              (?:\s+dst-port\s+([0-9]+)(?:/(tcp|udp))?)?
              \s+to
              \s+host\s+([0-9./]+)
              (?:\s+port\s+([0-9.-]+))}x
        inface, dsthost, dstport, proto, host, ports = $~[1..-1]
        nat_dst = make_host_rule(:dsthost => dsthost, :dstport => dstport,
                                 :proto => proto, :inface => inface)
        forward_src = make_host_rule(:inface => inface)
        forward_dst = make_host_rule(:dsthost => host, :dstport => ports)
        ipt_nat_rules << "-A acl-prerouting #{nat_dst} -j DNAT --to #{host}:#{ports}"
        ipt_input_rules << "-A acl-forward #{forward_src} #{forward_dst} -j ACCEPT"

      when %r{^snat
            (?:\s+out-interface\s+(\w+))?
            (?:\s+src-address\s+([0-9./]+))?
            (?:\s+src-port\s+([0-9]+)(?:/(tcp|udp))?)?
            (?:\s+to
            \s+host\s+([0-9./]+)
            (?:\s+port\s+([0-9.-]+))?)?}x
        outface, srchost, srcport, proto, host, ports = $~[1..-1]
        nat_src = make_host_rule(:srchost => srchost, :srcport => srcport,
                                 :proto => proto, :outface => outface)

        forward_src = make_host_rule(:srchost => srchost, :srcport => srcport)
        forward_dst = make_host_rule(:outface => outface)
        ipt_nat_rules << if host.nil?
          "-A acl-postrouting #{nat_src} -j MASQUERADE"
        else
          "-A acl-postrouting #{nat_src} -j SNAT --to #{host}:#{ports}"
        end
        ipt_input_rules << "-A acl-forward #{forward_src} #{forward_dst} -j ACCEPT"

      end
    end
  rescue Exception => e
      warn "failed on processing #{acl_file}: #{e}"
  ensure
    input_rule = ipt_input_rules.join("\n")
    nat_rule = ipt_nat_rules.join("\n")
    return input_rule, nat_rule
  end
end

def make_static(name)
  path = File.join($options[:conf_root], name)
  return File.open(path).read if File.file? path
end

if __FILE__ == $0
  $options[:conf_root] = ARGV[0] if not ARGV[0].nil?

  skel = YAML::load(DATA.read)
  input_rule =  make_acl_input()
  forward_rule, nat_rule = make_acl_nat()
  iptables = <<EOF
# GENERATED BY acl.rb (Jianing YANG <jianingy.yang@gmail.com>)
# from configuration #{File.expand_path $options[:conf_root]}
# created at #{Time.now}

*filter
## FILTER CHAIN DEFINIATIONS
#{skel[:filter_chains]}

## BASIC INPUT RULES
#{skel[:input_prolog]}
#{skel[:input_epilog]}

## BASIC FORWARD RULES
#{skel[:forward_prolog]}
#{skel[:forward_epilog]}

## ACL FILTER RULES
#{input_rule}
#{forward_rule}

## USER CUSTOM FILTER RULES
#{make_static 'custom-input'}

COMMIT

*nat
## NAT CHAIN DEFINIATIONS
#{skel[:nat_chains]}

## BASIC NAT RULES
#{skel[:nat_prolog]}
#{skel[:nat_epilog]}

## ACL NAT RULES
#{nat_rule}

## USER CUSTOM NAT RULES
#{make_static 'custom-nat'}
COMMIT
EOF

  print iptables
end

__END__

:input_prolog: |
  -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT
  -A INPUT -m state --state INVALID -j DROP
  -A INPUT -i lo -j ACCEPT
  -A INPUT -j acl-pre-input
  -A INPUT -j acl-input
  -A INPUT -j acl-post-input
  -A INPUT -p tcp -m tcp -j REJECT --reject-with tcp-reset
  -A INPUT -p udp -m udp -j REJECT --reject-with icmp-port-unreachable
  -A INPUT -j REJECT --reject-with icmp-proto-unreachable

:input_epilog: ""

:forward_prolog: |
  -A FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT
  -A FORWARD -m state --state INVALID -j DROP
  -A FORWARD -j acl-pre-forward
  -A FORWARD -j acl-forward
  -A FORWARD -j acl-post-forward
  -A FORWARD -j REJECT --reject-with icmp-proto-unreachable

:forward_epilog: ""

:nat_prolog: |
  -A PREROUTING -j acl-pre-prerouting
  -A PREROUTING -j acl-prerouting
  -A PREROUTING -j acl-post-prerouting
  -A POSTROUTING -j acl-pre-postrouting
  -A POSTROUTING -j acl-postrouting
  -A POSTROUTING -j acl-post-postrouting

:nat_epilog: ""

:filter_chains: |
  :INPUT ACCEPT [0:0]
  :FORWARD ACCEPT [0:0]
  :OUTPUT ACCEPT [0:0]
  :acl-pre-input - [0:0]
  :acl-input - [0:0]
  :acl-post-input - [0:0]
  :acl-pre-forward - [0:0]
  :acl-forward - [0:0]
  :acl-post-forward - [0:0]

:nat_chains: |
  :PREROUTING ACCEPT [0:0]
  :INPUT ACCEPT [0:0]
  :OUTPUT ACCEPT [0:0]
  :POSTROUTING ACCEPT [0:0]
  :acl-pre-prerouting - [0:0]
  :acl-prerouting - [0:0]
  :acl-post-prerouting - [0:0]
  :acl-pre-postrouting - [0:0]
  :acl-postrouting - [0:0]
  :acl-post-postrouting - [0:0]
